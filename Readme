BAJOS is a run-time environment for microcontroller. It consists of BAJVM, a Java Virtual Machine
and of BAJOSBOOT, a collection of system classes. BAJOS can be adapted to Embedded Systems with/without operating system. BAJOS is a development of HWR-Berlin, faculty of Company-Linked Programs, department for informatics. See the file "license.terms" for information on usage and redistribution.
The system has been tested for 8 Bit and 32 AVR controllers on different development boards and works under Linux on PC or Linux for Embedded Systems.
Installation of Bajos requires:
	- C-compiler (gcc) on a cross development linux-PC
	- (serial) interfaces between PC and development board for programming and interaction
	- at least 80 kByte program memory on the controller board
	- at least 4 kByte data memory on the controller board
Boot classes in BAJOSBOOT include necessary classes of the JVM-specification, other useful system classes as well as the class PlatForm.java for binding the run time environment to the hardware configuration.

BAJOS version 0.5 is developed and compiled under Suse11.1 with the atmel tools for Suse11.1 and avr32studioV2.1.2 (avr-gcc version 4.13, avr32-ggc version 4.2.2). BAJOSVers.05, compiled for AVR8 processors (atmega128, atmega1280), expects the bootclasses and application classes in the flash memory. That enlarges the data ram space for the java heap and stack.
Bajos for the ArduinoMega board with the atmega1280 and bajos for the EVk1100 board with the AVR32UC3A can be compiled as well as a stand alone application or as program, started from resident monitor (bamo128 or bamo32 in cs.ba-berlin.de).
Every variant allows the interaction with a terminal program (RS232-serial communication) after starting.

GOALS OF BAJOS
The main motivation for developing BAJOS is to create an open source software for education of computer science students at an advanced technical college. Students are to be able to translate the theoretical knowledge in practical exercises. Java is appropriate for that particularly because the java run time environment includes elements of operating systems and the java specification lets students go way for creative ideas here. The combination of application software development in java, the programming of the jvm and native code device drivers in C/C++, the use of gnu development tools, the working in groups for an extensive software system and the use of an version control system under linux prepare the students for their job as software developers.

FEATURES AND LIMITS OF BAJOS
BAJOS contains a byte code interpreter, exception handling, multithreading and the
java synchronization mechanism, a garbage collected heap and a native code interface.
Currently BAJOS is based or better "inspired" on the JVM-specification (nowtoday only < version 1.6)
with exceptions and limits. 
Known differences are:
- no long data type
- no double data type
- no unicode support
- no full run time evaluation of all class/method/field-attributes
- no overloaded native methods
- no complete exception handling
- less than 256 classes/methods/local variables in methods
- less than 16 kwords (32 bit) on heap
- Array objects have no type information
- No typechecking in the bytecode handlers for *ASTORE
- *RETURN throws no IllegalMonitorStateException
- String constants are not automatically embedded in a java.lang.String object. If you encounter problems for example with casting String constants, try 'new String("STRINGCONSTANT")' instead of '"STRINGCONSTANT"'
- No Serialization, no java.lang.Serializable
- No hashCode() methods
- No System properties
- No java.lang.Class, no getClass() methods
- No java.lang.NumberFormatException, it is replaced by java.lang.IllegalArgumentException
- No class java.lang.Number and no shortValue, floatValue, byteValue, longValue methods in subclasses.
- No java.lang.Comparable, no compareTo() methods 

The amount of used boot- and system-classes and the complexity of exception handling
must be adapted on the available memory space on your target system.
Java software can be developed with these limits on a PC and compiled with javac.
Classfiles -compiled on external machines- can be included.

HISTORY
The project is used in an academic environment for a deeper understanding of
lectures in C++/Java-programming, unix-system programming ,embedded systems and operating systems.
First version was created in 2006 for PC-linux and quickly ported for atmega128
(development board CharonII with 32 kbyte ram and mica2dot only with internal flash/ram).
Since 2007/08 BAJOS works on the AVR32 processors UC3A (stand alone application) and AP7000
(stand alone and linux).
BAJOS is used currently for controlling of peripheral equipment of embedded systems.
It is planned to improve the binding of BAJOS at the AVR32 development boards, the processing
of java 1.6 compiled classfiles, the porting to other processor architectures, to improve
the run time behavior of BAJOS, to develop better scheduler, .....

INSTALLATION AND INITIALIZATION
PREPARATIONS ON PC
Installation of the GNU-C-development tools for the platform.
The actual BAJOS-version was compiled under Suse11.1 for AVR8 with the Tools shipped by Suse
and for AVR32 with the atmel tools for Suse11.1. Later software versions require
BAJOS software (especially hardware drivers) adjustment.
The bootclasses are compiled with Sun's java.
Unpack BAJOS (bajvm and bajosboot), translate and compile for your target (ch, evk1100, stk1000, ngw100, linux, avr32-linux) in the BAJOS directory
#>make clobber target				// clean all objects and executable
#>make clean compile target			// generate target executable
#>make clean debug compile verbose target 	// generate target executable for debugging
#>make all target				// generate executable and bootclasses, ...

TESTING ON LINUX-PC
#> make all linux
generates the virtual machine executable bajvm and in BAJOSBOOT/classes the boot/system-classes.
#> make compPC linux  # PC stands here for ProducerConsumer
generates e.g. the application class ProducerConsumer.class (and Buffer.class) compiled against the bajos boot classes.
#> make PC linux
starts the virtual machine, loads the boot classes and loads and executes the application classes.
It is also possible to work with "professional" java:
javatests#> javac ProducerConsumer.java
javatests#> java ProducerConsumer

PREPARATION OF DEVELOPMENT BOARDS

ARDUINOMEGA WITH ATMEGA1280 as standalone application
Install an appropriate terminal program for serial communication on your pc (e.g. kermit or minikermit from cs.ba-berlin.de).
Download and unpack bajosV05.tar.gz.
Connect your arduinoMega with a programming adapter (we user AVRispmkII) via usb cable with your pc.
Maybe you must set set atmega1280 fuses with:
#> make writeFusesA am		# start at 0x0000 (boot section) after reset
Type:
#> make all arduinoMega
generates the virtual machine, the bootclasses and the applicationclass javatests/AM.class and
programs the virtual machine and all classes (bajos) in the flash.
Then connect the arduinoMega with an usb cable with the pc and start the terminal program.
The application class javatests/AM.class starts after reset.with a test program (test timer, blinking led) and communicates with the terminal program.
If you modify the Makefile (change the macro AVR8APPSOURCES), you can run your own application.
Your classes myst be compiled with javac against the bootclasses in with the compiler options -g:none -source 1.4. The Makefile do it for you.

ARDUINOMEGA WITH ATMEGA1280 with monitor bamo128
Load first the monitor in the arduinoMega board (see cs.ba-berlin.de - bamo128.tar.gz).
Download and unpack bajosV05.tar.gz.
Maybe you must set set atmega1280 fuses with:
#> make writeFusesM am		# start at 0xf000 (boot section) after reset
Type:
#> make all arduinoMega withmon
in the bajos directory. This creates the file binary files bajvm.bin (jvm), avr8bootpack (bootclasses) and amapp (arduinoMega application classes).
Install the terminal program for serial communication on your pc (minikermit from cs.ba-berlin.de)
and start it. You see the monitor prompt after reset on the pc-terminal:
    ___________________BAMo128 Version:0.07 _________________
     from students of the BA Berlin written for the ArduinoMega

    BAMo128 #>
now type 'w':
    BAMo128 #>name of cob (bin) -file for uploading:
type here on the terminal the filename of the vm: bajvm.bin.
After loading the vm you load the boot classes with the j-command and the flash
word address B000.
	Bamo128 #> j
write flash words from 0000 to ff80(128 words pages):B000
type w: name of cob (bin) -file for uploading: avr8bootpack
(Don't forget to type 'w').
Repeat the same procedure for loading the application classes amapp with the flash
word address D800.
The addresses B000 and D800 are defined in definitions.h and point at free flash space
between 0- ~9800 (bajvm) and the monitor f000-ffff.
Now you can start bajvm with the monitor command
	BAM0128#> g 0
The application class javatests/AM.class is executed now and returns to the monitor prompt.

You can only change the source file AM.java in javatests/ you compiles it to AM.class and generate
the application class packages (amapp) with:
#>make compAM amapp am
and upload this packages with th j command from monitor.
You can upload further boot classes and more than on application class by modification of the Makefile.

CHARONII WITH ATMEGA128
We use the monitor program bamo128 (cs.ba-berlin.de). This monitor is burned in flash
with uisp in the upper boot section (4kwords a 16 bit) at 0xF000 (word address).
You can load with bamo128 programs and data ind the flash.
Connect the CharonII (or equivalent board) with the PC over a serial communication line.
For te atmega128 we store all classfiles in the ram, because the data acces to the flash
is to slowly. You can on the PC generate with:
#>make all avr8
the virtual machine bajvm.bin for the atmega128 processor and a file "avr8bootpack" (all bootclasses in one file), a small subset of bootclasses, which is used for upload the CharonII with the bootclasses and the application class package avr8app.
Load this 3 files in the CharonII board described above.

Then with
BAMo128 #>g	0	# starts at address 0x0000
you start bajvm and the aplication.
Primary interaction is with PC-minikermit. In the atmega128 environment the classfiles are now (version 0.5) stored in the flash. The adjustment of BAJVM for the memory limits is carried out in limits.h before compiling.

STANDALONE BAJOS on EVK1100, STK1000 AND NGW100 WITH AVR32UC3A/AR32AP7000
BAJOS and the boot/systemclasses are written here with a programming adapter (JTAG interface)
in the internal/external flash memory.
The application classes are loaded after starting of BAJOS in the external RAM.
#>make all target (target: evk1100, ngw100 or  stk1000)
compiles and loads BAJVM and the bootclasses on the target system.
#>make compEVK1100 evk1100
compiles e.g. the application javatests/EVK1100.java against the bajos-bootclasses for the EVK1100 board.
Now start minikermit (cs.ba-berlin.de) on PC and reset the target system, bajvm runs.
Then you can load the application classes from the command line.
After this starts the java program execution with the main interaction over the terminal program. 

BAJOS FOR AVR32-LINUX ON NGW100 OR STK1000
#> make all avr32-linux
generates on PC the executable bajvm.
#> make compPC avr32-linux
generates e.g. the application classes ProducerConcumer.class and Buffer.class in dir jajatests.
Copy bajvm, all needed bootclasses (have a look at the Makefile for bootclasses) from BAJOSBOOT/classes (do not forget Plattfom.class) and the application class on a SD-card.
Connect the PC with the avr-linux running target hardware with a terminal program  (e.g. minikermit), boot
avr32-linux and change to the SD card directory.
Start from terminal the virtual machine and the application class. 
##> ./bajvm *.class

PORTING ON OTHER TARGET PLATFORMS
We have ported BAJOS on 8 Bit up to 64 Bit processors with little endian/big endian data memory access. Therefore it seems to have not a great effort to port BAJOS on other platforms with the indicated
memory equipment and a C-compiler. Adaptations are to be carried out in the files:
native.c, platform.c, stack.c, heap.c, classfile.c, bajvm.c, limits.h, typedefinitions.h
These are in the first row related to the memory partioning and the serial communication line binding.

COMPILING JAVA SOURCES FOR BAJOS
Since BAJOSBOOT is not J2SE compatible yet , it is necessary to compile java classes against BAJOSBOOT. A corresponding call of javac might look like
#> javac -g:none -source 1.4 -extdirs . -bootclasspath $(BAJOSBOOT) -d $(TARGET) -sourcepath $(SOURCES) $(SOURCEFILE)
where $(BAJOSBOOT) is the directory containing the BAJOSBOOT classes (currently "BAJOSBOOT/sources" below Bajos root) and $(TARGET) and $(SOURCES) point to the application's binary and source directories.

KNOWN BUGS
look at bugs ??...



BAJOS ist eine Laufzeitumgebung für Mikrokontroller und besteht aus den Komponenten BAJVM, eine Java Virtual Maschine und aus BAJOSBOOT mit Java-Systemklassen und kann mit/ohne Betriebssystem
in Eingebetteten Systemen verwendet werden.
BAJOS wurde für den 8 Bit Controller atmega128, die 32 Bit Controller
AVR32UC3A und AVR32AP7000 getestet und läuft auch unter Linux auf dem PC.
Voraussetzung für die Installation von BAJOS ist:
	- ein C-Compiler (gcc) auf einem Entwicklungs-PC
	- eine (serielle) Schnittstelle zwischen PC und Entwicklungsboard
	  zur Programmierung und Interaktion
	- mindestens 80 KByte Programmspeicher auf dem Controllerboard
	- mindestens 4 KByte Datenspeicher auf dem Controllerboard
Die Bootklassen in BAJOSBOOT umfassen notwendige Klassen der
JVM-Spezifikation, weitere nützliche Systemklassen sowie in
der Klasse PlatForm.java die Anbindung der Laufzeitumgebung
an die gegebene Hardware-Konfiguration.

Eigenschaften und Grenzen von BAJOS
BAJOS beinhaltet einen Bytecodeinterpreter, Exception Handling, Threadunterstützung,
Unterstützung der Sychronisationsmechanismen von Java, native Methoden-Interface
und einen Garbagecollector.
Beim gegenwärtigen Stand ist BAJOS angelehnt oder besser "inspiriert"  von der JVM-Spezifikation
(gegenwärtig nur < Version 1.6) mit Ausnahmen und Einschränkungen.
Die bekanntesten Abweichungen sind:
- kein long Datentyp
- kein double Datentyp
- keine Unicode-Unterstützung
- keine Laufzeitauswertung einiger Klassen/Methoden/Field-Attribute
- keine überladenen native Methoden
- kein vollständiges Exception Handling
- weniger als 256 Klassen;256 Methoden/Klasse; 256 lokale Vars. für Methoden
- weniger als 16K Worte a 32 Bit auf dem Heap.
- Arrays haben keine Typinformationen 
- Die Handler für die *ASTORE-Bytecodes führen keine Typüberprüfung durch
- *RETURN kann keine IllegalMonitorStateException auslösen
- Stringkonstanten werden nicht automatisch in eine java.lang.String-Instanz verpackt. Insbesondere bei casting-Problemen sollte 'new String("STRINGCONSTANT")' anstelle von '"STRINGCONSTANT"' verwendet werden.
- Keine Serialisierung, kein java.lang.Serializable
- Keine hashCode()-Methoden
- Keine System-Properties
- Keine java.lang.Class, kein getClass()-Methoden
- Keine java.lang.NumberFormatException, wird ersetzt durch java.lang.IllegalArgumentException
- Kein java.lang.Number und keine shortValue()-, floatValue()-, byteValue()-, longValue()-Methoden in den Unterklassen.
- Kein java.lang.Comparable, keine compareTo()-Methoden

Der Umfang der verwendeten Boot- und Systemklassen und das
programmspeicheraufwendige Exception-Handling muß dem vorhandenen
Speicherplatz angepasst werden. 

Javasoftware kann mit diesen Einschränkungen auf dem PC entwickelt
und mit javac compiliert werden, Classfiles - auf Fremdmaschinen compiliert -
eingebunden werden.

Historie
Zur Vertiefung von Vorlesungsinhalten (Programmierung in Java und C/C++,
Betriebssysteme, Embedded Systems) enstand die Idee, eine JVM zu realisieren.
Nach konzeptioneller Arbeit, in der die wichtigsten Datenstrukturen
definiert wurden, entstand 2006 eine Version, welche auf Linux lauffähig
war. Diese wurde relativ schnell auf Boards mit dem atmega128 portiert
(Charon II mit 32 KByte externen Ram und wenig später auf den
MICA2Dot der Firma Crossbow, welcher nur mit dem internen Mikrokontroller-Speicher
auskommt). 2007/08 erfolgte eine Portierung auf die 32 Bit Prozessoren
AVR32UC3A und AVR32AP7000 (unter Linux und als standalone Anwendung). Für das
Entwicklungsboard STK1000 wird gegenwärtig eine grafische Bibliothek für das
LCD-Display auf diesem Board entwickelt.
Neben der intensiven Arbeit an der Erweiterung, Erhöhung der Stabilität und Verbesserung
des Laufzeitverhaltens wird an der Weiterentwicklung (z.B.Verbesserung des Thread-Schedulers)
und an der Realisierung von Applikationen (Steuerung von Robotern, ferngesteuerten Mobilen,..)
gearbeitet.

Installation und Inbetriebnahme

Vorbereitung auf dem PC
Installation die GNU-C-Entwicklungstools für die gewünschte Plattform
(avrgcc oder avr32-gcc). In Suse10.3 sind die Tools bereits enthalten und können
mit yast von der Installations-CD geladen werden. Für die AVR32-Prozessoren wurden
die Suse10.1 Tools von atmel verwendet. Für spätere Versionen sind Anpassungen notwendig.
Entpacken von BAJOS und BAJOSBOOT.
Übersetzen von BAJOS für das Target (avr8, evk110, ngw100, stk1000, linux, avr32-linux)
im Verzeichnis bajos.
#>make clean target				// löscht alle Objekte und Executable
#>make clean compile target			// erzeugt dassprechenden Zielexecutable
#>make clean debug compile verbose target 	// erzeugt Executable für Debugging

Vorbereitung des Entwicklungsboards
CharonII mit atmega128
Hier ist es zweckmäßig den Monitor bamo128 (cs.ba-berlin.de) mit einem
Programmiergerät in die oberen 4 KWorte des Instruktionsspeichers (16Bit) zu brennen und den atmega128 zum Start auf der Bootloaderadresse 0xF000 (Wortadresse) zu programmieren.
Dann kann mittels ISP-Programming über bamo128 und Terminalprogramms (minikermit von
cs.ba-berlin.de) die JVM in den Instruktionsspeicher Mikrocontroller geladen werden.
Nach Start von bajos werden die  Bootklassen (ca. 1 Dutzend Klassen, notwendig
für die Java-Laufzeitumgebung) und anschließend die Anwenderklassen geladen.
Die Class-Files werden hier in den RAM geladen. Die Anpassung von BAJOS an den vorhandenen
Datenspeicher erfolgt vor dem Compilieren in limits.h.

EVK1000, STK1000 und NGW100 mit AVR32UC3A/AR32AP7000
Hier werden BAJOS und das Bootklassenpaket mit einem Programmiergerät in den
Flashspeicher geschrieben, die Anwendungsklassen werden nach dem Start von BAJOS in den
RAM nachgeladen.
#> make program stk1000
Lädt und startet die JVM und die Bootklassen  und startet die JVM. Diese
lädt über die Terminalschnittstelle die Anwenderklassen nach und startet die Abarbeitung.

Entwickelt und getestet wurde unter Suse10.3 mit den Atmel-GNU-Tools für Suse10.1 und den Treibern auf der Atmel-CD "STK1000_NGW_BSP_CD_Image_2.0.0". Neuere Softwareversionen erfordern eine mühsame Anpassung, da die firmenspezifischen Treiberbeispiele einer ständigen Änderung unterworfen sind.
Gegenwärtig arbeitet der C-Compiler und Linker nur mit dem knappen internen Speicher und der Speicher für den Java-Heap, die Java-Stacks und die
Anwendungs-Classfiles wird hart über Pointer (in bajvm.c -> eine unbefriedigende Lösung) an den großen externen RAM gebunden.
Es wird für den AVR32UC3A auf dem Board EVK1100 an einem Monitor gearbeitet, der auch
eine In-System-Programmierung des Flash ermöglicht und ein Laden der Class-Files
nach dem Starten von BAJOS ermöglicht.

Nach dem Starten von BAJOS und dem Laden aller Klassen ermöglicht jede Variante die
Interaktion mit einem Terminal, in Linux das aufrufende Terminal und bei den Entwicklunsgboards über die serielle Schnittstelle mit einem Terminalprogramm (z.B. minikermit von cs.ba-berlin.de). Dazu ist erfolgt in Java die Anbindung in die Systemklassen OutStream und InStream, so daß Ein-/Ausgaben über System.out.println(..) und System.in.read() getätigt werden können.

Tools
Die Compilierung der Boot/Systemklassen erfolgt über make-Ziele plattformabhängig:
#>make boot target (avr8 evk1100 ngw100 stk1000 linux)
erzeugt die Boot-und Systemklassen.
#> make A linux
Startet die JVM unter Linux lädt automatisch alle im Makefile angegebenen notwendigen Klassen.
#> make compA linux
ist eine Hilfe zum Kompilieren der Anwenderklasse A.java
Dieses und ähnliche Ziele wurde für Testzwecke eingeführt.

Portieren auf andere Zielplattformen und Controller
Aus den positiven Erfahrungen bei der Portierung auf 8-64 Bit Maschinen mit Datenspeicherung
im big endian/little endian Mode sehen wir keine Probleme, BAJOS auf andere Hardwareplattformen mit der oben angegebenen Mindestspeicheraustattung zu portieren.
Voraussetzung ist ein C-Compiler und der angegebene Mindestspeicherplatz für
Programme und Daten. Anpassungen für einen ersten Test sind in den C-Files und Headers
native.c
platform.c
stack.c
heap.c
classfile.c
bajvm.c
limits.h
typedefinitions.h
und betreffen im wesentlichen die Speicheraufteilung und die Anbindung
der Schnittstelle zum PC (serial).

FÜR BAJOS KOMPILIEREN
Da BAJOSBOOT nicht J2SE-kompatibel ist, müssen Klassen gegen BAJOSBOOT kompiliert werden. Ein entsprechender javac-Aufruf könnte wie folgt aussehen:
> javac -g:none -source 1.4 -extdirs . -bootclasspath $(BAJOSBOOT) -d $(TARGET) -sourcepath $(SOURCES) $(SOURCEFILE)
Dabei ist $(BAJOSBOOT) das Verzeichnis, in dem sich die BAJOSBOOT-Klassen befinden (zur Zeit "BAJOSBOOT/sources" vom Bajos-Verzeichnis aus) und $(TARGET) und $(SOURCES) zeigen auf die Klassen- und Quell-Verzeichnisse der zu kompilierenden Anwendung.

KNOWN BUGS
look at bugs ??...

Known Bugs
many ???

ToDo
Anpassung an java 1.6
Exception Handling für alle betroffenen Bytecodes realisieren/ oder auch nicht, wir bauen keinen mercedes!!
....
