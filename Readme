23.11.08 
BAJOS is a run-time environment for microcontroller. It consists of BAJVM, a Java Virtual Machine
and of BAJOSBOOT, a collection of system classes. BAJOS can be adapted to Embedded Systems with/without operating system.
The system has been tested for 8 Bit and 32 AVR controllers on different development boards and works under Linux on PC or Linux for Embedded Systems.
Installation of Bajos requires:
	- C-compiler (gcc) on a cross development PC
	- (serial) interface between PC and development board for programming and interaction
	- at least 80 kbyte program memory on the controller board
	- at least 4 kbyte data memory on the controller board
Boot classes in BAJOSBOOT include necessary classes of the JVM-specification, other useful system
classes as well as the class PlatForm.java for binding the run time environment to the hardware
configuration.

BAJOS is developed under Suse10.3 with the atmel tools for Suse10.1 and drivers from 
STK1000_NGW_BSP_CD_Image_2.0.0. Newer AVR32-software releases require cumbersome adaptations because the company-specific driver examples are permanently changed. The C-compiler and the linker for AVR32 processors currently work with the tight internal ram. Memories for classfiles, heap, stack,.. are hard wired with the external ram.
Every variant allows the interaction with a terminal program (RS232-serial communication) after starting.

FEATURES AND LIMITS OF BAJOS
BAJOS contains a byte code interpreter, exception handling, multithreading and the
java synchonization mechanism, a garbage collected heap and a native code interface.
Currently BAJOS is based or better "inspired" on the JVM-specification (nowtoday only < version 1.6)
with exceptions and limits. 
Known differences are:
- no long data type
- no double data type
- no unicode support
- no full run time evaluation of all class/method/field-attributes
- no overloaded native methods
- no complete exception handling
- less than 256 classes/methods/local variables in methods
- less than 16 kwords (32 bit) on heap
- Array objects have no type information
- No typechecking in the bytecode handlers for *ASTORE
- *RETURN throws no IllegalMonitorStateException
- String constants are not automatically embedded in a java.lang.String object. If you encounter problems for example with casting String constants, try 'new String("STRINGCONSTANT")' instead of '"STRINGCONSTANT"'
- No Serialization, no java.lang.Serializable
- No hashCode() methods
- No System properties
- No java.lang.Class, no getClass() methods
- No java.lang.NumberFormatException, it is replaced by java.lang.IllegalArgumentException
- No class java.lang.Number and no shortValue, floatValue, byteValue, longValue methods in subclasses.
- No java.lang.Comparable, no compareTo() methods 

The amount of used boot- and system-classes and the complexity of exception handling
must be adapted on the available memory space on your target system.
Java software can be developed with these limits on a PC and compiled with javac.
Classfiles -compiled on external machines- can be included.

HISTORY
The project is used in an academic environment for a deeper understanding of
lectures in C++/java-programming, unix-system programming ,embedded systems and operating systems.
First version was created in 2006 for PC-linux and quickly ported for atmega128
(development board CharonII with 32 kbyte ram and mica2dot only with internal flash/ram).
Since 2007/08 BAJOS works on the AVR32 processors UC3A (stand alone application) and AP7000
(stand alone and linux). Currently a graphical library is adapted for the
lcd graphic display on the stk1000 development board.
BAJOS is used currently for controlling of peripheral equipment of embedded systems.
It is planned to improve the binding of BAJOS at the AVR32 development boards, the processing
of java1.6 compiled classfiles, the porting to other processor architectures, to improve
the run time behavior of BAJOS, to develop better scheduler, .....

INSTALLATION AND INITIALIZATION
PREPARATIONS ON PC
Installation of the GNU-C-development tools for the platform.
The actual BAJOS-version was compiled under Suse10.3 for AVR8 with the Tools shipped by Suse
and for AVR32 with the atmel tools for Suse10.1. Later software versions require
BAJOS software adjustment.
Unpack BAJOS (bajvm and bajosboot), translate and compile for your target (avr8, evk1100, stk1000, ngw100, linux, avr32-linux) in the BAJOS directory
#>make clean target				// clean all objects and executable
#>make clean compile target			// generate target executable
#>make clean debug compile verbose target 	// generate target executable for debugging
#>make all target

PREPARATION OF DEVELOPMENT BOARD
CHARONII WITH ATMEGA128
We use the monitor program bamo128 (cs.ba-berlin.de). This monitor is burned in flash
with uisp in the upper boot section (4kwords a 16 bit) at 0xF000 (word address).
For te atmega128 we store all classfiles in the ram, because the data acces to the flash
is to slowly. You can generate with:
#>make bootclasses avr8
a file "avr8bootclasses", which is used for upload the atmega128 with the bootclasses.
With minikermit on the PC (cs.ba-berlin.de) you can now load with ISP-programming and
the w-command of bamo128 the compiled BAJVM in the atmega128 flash memory (address 0x80 in words).
Then with
#>g 80
you start BAJOS, which loads on prompt request the boot/system classes "avr8bootclasses" and applications classes in data ram und executes your java program. Primary interaction is with PC-minikermit.
In the atmega128 environment the classfiles are stored in the data-RAM (4k for atmaga Ram only and
32k for the CharonII). The adjustment of BAJVM for the memory limits is carried out
in limits.h before compiling.

EVK1000, STK1000 AND NGW100 WITH AVR32UC3A/AR32AP7000
BAJOS and the boot/systemclasses are written here with a programming adapter (JTAG interface)
in the internal/external flash memory.
The application classes are loaded after starting of BAJOS in the external RAM.
#>make program target (target: evk1100, ngw100, stk1000)
loads and starts BAJVM and the bootclasses.
The application classes you can load in a x-terminal program after starting of minikermit (cs.ba-berlin.de) form the command line.
After this starts the java program execution with the main interaction over the terminal program. 

PORTING ON OTHER TARGET PLATFORMS
We have ported BAJOS on 8 Bit up to 64 Bit processors with little endian/big endian data memory access. Therefore it seems to have not a great effort to port BAJOS on other platforms with the indiceted
memory equipment and a C-compiler. Adaptations are to be carried out in the files:
native.c, platform.c, stack.c, heap.c, classfile.c, bajvm.c, limits.h, typedefinitions.h
These are in the first row related to the memory partioning and the serial communication line binding.

COMPILING JAVA SOURCES FOR BAJOS
Since BAJOSBOOT is not J2SE compatible yet , it is necessary to compile java classes against BAJOSBOOT. A corresponding call of javac might look like
> javac -g:none -source 1.4 -extdirs . -bootclasspath $(BAJOSBOOT) -d $(TARGET) -sourcepath $(SOURCES) $(SOURCEFILE)
where $(BAJOSBOOT) is the directory containing the BAJOSBOOT classes (currently "BAJOSBOOT/sources" below Bajos root) and $(TARGET) and $(SOURCES) point to the application's binary and source directories.

KNOWN BUGS
look at bugs ??...





BAJOS ist eine Laufzeitumgebung für Mikrokontroller und besteht aus den Komponenten BAJVM, eine Java Virtual Maschine und aus BAJOSBOOT mit Java-Systemklassen und kann mit/ohne Betriebssystem
in Eingebetteten Systemen verwendet werden.
BAJOS wurde für den 8 Bit Controller atmega128, die 32 Bit Controller
AVR32UC3A und AVR32AP7000 getestet und läuft auch unter Linux auf dem PC.
Voraussetzung für die Installation von BAJOS ist:
	- ein C-Compiler (gcc) auf einem Entwicklungs-PC
	- eine (serielle) Schnittstelle zwischen PC und Entwicklungsboard
	  zur Programmierung und Interaktion
	- mindestens 80 KByte Programmspeicher auf dem Controllerboard
	- mindestens 4 KByte Datenspeicher auf dem Controllerboard
Die Bootklassen in BAJOSBOOT umfassen notwendige Klassen der
JVM-Spezifikation, weitere nützliche Systemklassen sowie in
der Klasse PlatForm.java die Anbindung der Laufzeitumgebung
an die gegebene Hardware-Konfiguration.

Eigenschaften und Grenzen von BAJOS
BAJOS beinhaltet einen Bytecodeinterpreter, Exception Handling, Threadunterstützung,
Unterstützung der Sychronisationsmechanismen von Java, native Methoden-Interface
und einen Garbagecollector.
Beim gegenwärtigen Stand ist BAJOS angelehnt oder besser "inspiriert"  von der JVM-Spezifikation
(gegenwärtig nur < Version 1.6) mit Ausnahmen und Einschränkungen.
Die bekanntesten Abweichungen sind:
- kein long Datentyp
- kein double Datentyp
- keine Unicode-Unterstützung
- keine Laufzeitauswertung einiger Klassen/Methoden/Field-Attribute
- keine überladenen native Methoden
- kein vollständiges Exception Handling
- weniger als 256 Klassen;256 Methoden/Klasse; 256 lokale Vars. für Methoden
- weniger als 16K Worte a 32 Bit auf dem Heap.
- Arrays haben keine Typinformationen 
- Die Handler für die *ASTORE-Bytecodes führen keine Typüberprüfung durch
- *RETURN kann keine IllegalMonitorStateException auslösen
- Stringkonstanten werden nicht automatisch in eine java.lang.String-Instanz verpackt. Insbesondere bei casting-Problemen sollte 'new String("STRINGCONSTANT")' anstelle von '"STRINGCONSTANT"' verwendet werden.
- Keine Serialisierung, kein java.lang.Serializable
- Keine hashCode()-Methoden
- Keine System-Properties
- Keine java.lang.Class, kein getClass()-Methoden
- Keine java.lang.NumberFormatException, wird ersetzt durch java.lang.IllegalArgumentException
- Kein java.lang.Number und keine shortValue()-, floatValue()-, byteValue()-, longValue()-Methoden in den Unterklassen.
- Kein java.lang.Comparable, keine compareTo()-Methoden

Der Umfang der verwendeten Boot- und Systemklassen und das
programmspeicheraufwendige Exception-Handling muß dem vorhandenen
Speicherplatz angepasst werden. 

Javasoftware kann mit diesen Einschränkungen auf dem PC entwickelt
und mit javac compiliert werden, Classfiles - auf Fremdmaschinen compiliert -
eingebunden werden.

Historie
Zur Vertiefung von Vorlesungsinhalten (Programmierung in Java und C/C++,
Betriebssysteme, Embedded Systems) enstand die Idee, eine JVM zu realisieren.
Nach konzeptioneller Arbeit, in der die wichtigsten Datenstrukturen
definiert wurden, entstand 2006 eine Version, welche auf Linux lauffähig
war. Diese wurde relativ schnell auf Boards mit dem atmega128 portiert
(Charon II mit 32 KByte externen Ram und wenig später auf den
MICA2Dot der Firma Crossbow, welcher nur mit dem internen Mikrokontroller-Speicher
auskommt). 2007/08 erfolgte eine Portierung auf die 32 Bit Prozessoren
AVR32UC3A und AVR32AP7000 (unter Linux und als standalone Anwendung). Für das
Entwicklungsboard STK1000 wird gegenwärtig eine grafische Bibliothek für das
LCD-Display auf diesem Board entwickelt.
Neben der intensiven Arbeit an der Erweiterung, Erhöhung der Stabilität und Verbesserung
des Laufzeitverhaltens wird an der Weiterentwicklung (z.B.Verbesserung des Thread-Schedulers)
und an der Realisierung von Applikationen (Steuerung von Robotern, ferngesteuerten Mobilen,..)
gearbeitet.

Installation und Inbetriebnahme

Vorbereitung auf dem PC
Installation die GNU-C-Entwicklungstools für die gewünschte Plattform
(avrgcc oder avr32-gcc). In Suse10.3 sind die Tools bereits enthalten und können
mit yast von der Installations-CD geladen werden. Für die AVR32-Prozessoren wurden
die Suse10.1 Tools von atmel verwendet. Für spätere Versionen sind Anpassungen notwendig.
Entpacken von BAJOS und BAJOSBOOT.
Übersetzen von BAJOS für das Target (avr8, evk110, ngw100, stk1000, linux, avr32-linux)
im Verzeichnis bajos.
#>make clean target				// löscht alle Objekte und Executable
#>make clean compile target			// erzeugt dassprechenden Zielexecutable
#>make clean debug compile verbose target 	// erzeugt Executable für Debugging

Vorbereitung des Entwicklungsboards
CharonII mit atmega128
Hier ist es zweckmäßig den Monitor bamo128 (cs.ba-berlin.de) mit einem
Programmiergerät in die oberen 4 KWorte des Instruktionsspeichers (16Bit) zu brennen und den atmega128 zum Start auf der Bootloaderadresse 0xF000 (Wortadresse) zu programmieren.
Dann kann mittels ISP-Programming über bamo128 und Terminalprogramms (minikermit von
cs.ba-berlin.de) die JVM in den Instruktionsspeicher Mikrocontroller geladen werden.
Nach Start von bajos werden die  Bootklassen (ca. 1 Dutzend Klassen, notwendig
für die Java-Laufzeitumgebung) und anschließend die Anwenderklassen geladen.
Die Class-Files werden hier in den RAM geladen. Die Anpassung von BAJOS an den vorhandenen
Datenspeicher erfolgt vor dem Compilieren in limits.h.

EVK1000, STK1000 und NGW100 mit AVR32UC3A/AR32AP7000
Hier werden BAJOS und das Bootklassenpaket mit einem Programmiergerät in den
Flashspeicher geschrieben, die Anwendungsklassen werden nach dem Start von BAJOS in den
RAM nachgeladen.
#> make program stk1000
Lädt und startet die JVM und die Bootklassen  und startet die JVM. Diese
lädt über die Terminalschnittstelle die Anwenderklassen nach und startet die Abarbeitung.

Entwickelt und getestet wurde unter Suse10.3 mit den Atmel-GNU-Tools für Suse10.1 und den Treibern auf der Atmel-CD "STK1000_NGW_BSP_CD_Image_2.0.0". Neuere Softwareversionen erfordern eine mühsame Anpassung, da die firmenspezifischen Treiberbeispiele einer ständigen Änderung unterworfen sind.
Gegenwärtig arbeitet der C-Compiler und Linker nur mit dem knappen internen Speicher und der Speicher für den Java-Heap, die Java-Stacks und die
Anwendungs-Classfiles wird hart über Pointer (in bajvm.c -> eine unbefriedigende Lösung) an den großen externen RAM gebunden.
Es wird für den AVR32UC3A auf dem Board EVK1100 an einem Monitor gearbeitet, der auch
eine In-System-Programmierung des Flash ermöglicht und ein Laden der Class-Files
nach dem Starten von BAJOS ermöglicht.

Nach dem Starten von BAJOS und dem Laden aller Klassen ermöglicht jede Variante die
Interaktion mit einem Terminal, in Linux das aufrufende Terminal und bei den Entwicklunsgboards über die serielle Schnittstelle mit einem Terminalprogramm (z.B. minikermit von cs.ba-berlin.de). Dazu ist erfolgt in Java die Anbindung in die Systemklassen OutStream und InStream, so daß Ein-/Ausgaben über System.out.println(..) und System.in.read() getätigt werden können.

Tools
Die Compilierung der Boot/Systemklassen erfolgt über make-Ziele plattformabhängig:
#>make boot target (avr8 evk1100 ngw100 stk1000 linux)
erzeugt die Boot-und Systemklassen.
#> make A linux
Startet die JVM unter Linux lädt automatisch alle im Makefile angegebenen notwendigen Klassen.
#> make compA linux
ist eine Hilfe zum Kompilieren der Anwenderklasse A.java
Dieses und ähnliche Ziele wurde für Testzwecke eingeführt.

Portieren auf andere Zielplattformen und Controller
Aus den positiven Erfahrungen bei der Portierung auf 8-64 Bit Maschinen mit Datenspeicherung
im big endian/little endian Mode sehen wir keine Probleme, BAJOS auf andere Hardwareplattformen mit der oben angegebenen Mindestspeicheraustattung zu portieren.
Voraussetzung ist ein C-Compiler und der angegebene Mindestspeicherplatz für
Programme und Daten. Anpassungen für einen ersten Test sind in den C-Files und Headers
native.c
platform.c
stack.c
heap.c
classfile.c
bajvm.c
limits.h
typedefinitions.h
und betreffen im wesentlichen die Speicheraufteilung und die Anbindung
der Schnittstelle zum PC (serial).

FÜR BAJOS KOMPILIEREN
Da BAJOSBOOT nicht J2SE-kompatibel ist, müssen Klassen gegen BAJOSBOOT kompiliert werden. Ein entsprechender javac-Aufruf könnte wie folgt aussehen:
> javac -g:none -source 1.4 -extdirs . -bootclasspath $(BAJOSBOOT) -d $(TARGET) -sourcepath $(SOURCES) $(SOURCEFILE)
Dabei ist $(BAJOSBOOT) das Verzeichnis, in dem sich die BAJOSBOOT-Klassen befinden (zur Zeit "BAJOSBOOT/sources" vom Bajos-Verzeichnis aus) und $(TARGET) und $(SOURCES) zeigen auf die Klassen- und Quell-Verzeichnisse der zu kompilierenden Anwendung.

KNOWN BUGS
look at bugs ??...

Known Bugs
many ???

ToDo
Anpassung an java 1.6
Exception Handling für alle betroffenen Bytecodes realisieren/ oder auch nicht, wir bauen keinen mercedes!!
....
